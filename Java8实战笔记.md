[TOC]

# 一、基础知识

## 1. Java 8新特性

### 1.1 函数式编程

<font size=5>**函数式编程**</font>：将函数代码传递给方法的功能，其核心为——**把函数作为值**

<font size=5>**行为参数化**</font>：把方法代码作为参数传递给另一个方法的概念，是一种通过传递代码使操作行为实现参数化的思想。这是Java 8非常依赖的一种软件开发模式。

<font size=5>**无状态函数**</font>：函数的行为必须能够对不同的输入安全地执行，这意味着函数代码中不能访问共享的可变数据。这种函数称为***纯函数***，或***无副作用函数***，类似于数学概念上的函数，简单地接受输入，并输出结果。

>***没有共享的可变数据***、***将方法/函数即代码传递给其他方法的能力***，这两点是函数式编程范式的基石

<font size=5>**函数**</font>：编程语言中的*函数*通常指*方法*，与数学中的*函数*也就是*无状态函数*的意义相同。

- Java 8中新增了把*函数*作为*值*的新形式
- 编程语言的整个目的就在于操作*值*
  - Java程序中的基本类型与对象类型值被称为***一等值***（一等公民）
  - 编程语言中的其他结构在程序执行期间不能传递，称为***二等值***（二等公民），如Java 8之前的方法和类
  - Java 8中允许方法和代码作为值，即让方法成为*一等值*，通过创建**方法引用**来传递
- **函数式编程风格**：即编写把函数作为一等值来传递的程序（其中Lambda表达式作为一种广义上的*匿名函数*）

### 1.2 Stream流

<font size=5>**Stream流**</font>：一系列数据项，一次只生成一项，程序可以从输入流中依次读取数据项，然后以同样的方式将数据项写入输出流。可以将Stream看做一种迭代器，不同的数据处理操作可以并行执行

- **外部迭代**：使用for-each循环遍历和处理集合中的元素
- **内部迭代**：使用Stream API来处理集合中的元素，数据迭代完全在库内部进行

<font size=5>Stream流解决的问题</font>

- 集合处理时的繁琐和晦涩

  - 集合操作中经常有反复出现或相近的数据处理模式，但需要频繁的for-each循环遍历
  - 使用Stream把迭代转为内部

- 难以利用多核实现并行

  - 集合操作常常可以并行化

  - 在Java 8之前可以通过多线程来利用并行化，但是需要进行线程同步/协调：因为线程可能会同时访问并更新共享变量。

  - Java 8的Stream API使用的是强调尽可能少地使用synchronized等线程同步手段的函数式编程风格，它重点在于==***数据分块***==而不是***协调同步***

    - 流操作针对的是，对每个集合元素的操作之间互不相关互不干扰，使之可以进行数据分块而进入不同的CPU进行处理

      >流提供的几乎是“免费”的并行，但是只有在元素处理的方法不会“互动”（比如方法间有可变的共享对象等）才能工作。
      >
      >函数式编程中的函数的主要意思是“把函数作为一等值”，其中还隐含着第二层意思，即“***执行时在元素之间无互动***”

<font size=5>Stream API</font>

- Stream API和Collection API都能够访问数据序列
- Collection API主要为了存储和访问数据
- Stream API主要用于描述对数据的计算，强调对Stream中元素的==***并行处理***==

### 1.3 默认方法

- 给接口加入一个新方法，意味着所有的实现类都必须为其提供一个实现，如何改变已发布的接口而不破坏已有的实现？
- Java 8中引入了**默认方法**：接口可以包含实现类没有提供实现的方法签名，缺失的方法主体随接口提供。这增加了扩充接口的自由度，同时不会破坏现有的实现

- 随之产生了一个问题：一个类只能继承一个父类，但是允许实现多个接口。如果多个接口中有多个默认实现，是否会产生某种形式的***多重继承*** ？或者说出现***菱形继承***问题 ？



## 2. 通过行为参数化传递代码

<font size=5>**行为参数化**</font>：帮助处理频繁变更需求的一种***软件开发模式***。它表示可以编写一段代码但可以先不执行，这段代码可以在之后被程序的其他部分调用。即将不同的代码作为参数传递给另一个方法，并稍后由方法在其内部去执行这段代码。而接受代码作为参数的方法的行为就基于此块代码，也即方法的行为==被参数化==。

- 实现行为参数化：
  - 接口 + 实现类：将频繁变动的行为单独分离出来抽象成接口方法，并将代码封装在实现类内，让方法接受接口类型的对象
    - 即使代码只使用一次也需要声明后实例化一个实现类，类的数量激增，且繁琐
  - 接口 + 匿名类：使用匿名类允许同时声明和实例化一个类，随用随建，无需命名
    - 匿名类虽然不用事先声明实现类，但是仍然要创建一个对象，并明确地实现一个方法来定义一个新的行为。略显笨重，不够清晰
  - 接口 + Lambda表达式：只需要传递行为本身
  - 接口 + Lambda表达式 + 类型参数T：将方法升级为泛型方法，提供更高层次的抽象



## 3. Lambda表达式





















