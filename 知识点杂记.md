# 一、计算机网络

## 1、HTTP协议

### 1.1 URI和URL

- URI：统一资源定位符，Uniform Resource Identifier。
  - Uniform：规定统一的格式处理不同类型的资源
  - Resource：可标识的任何资源
  - Identifier：用于标识资源

- URI就是由某个协议方案表示的资源的定位标识符，用字符串标识互联网资源。而URL表示资源的地点。URL是URI的子集。

### 1.2 Cookie

HTTP协议是一种不保存状态的协议，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存（对发送过的请求或者响应都不做持久化处理），这也就意味着无法根据之前的状态进行本次请求的处理（无法进行用户识别和状态管理），因此引入了Cookie技术。

​    由于HTTP协议是无状态的，所以HTTP协议本身非常简单，可以使得服务更快的处理请求以及响应，确保协议的可伸缩性。

### 1.3 报文和实体

- 报文：HTTP通信的基本单位，8位组字节流，由报文首部和报文主体组成。我理解的是其作为HTTP协议中的一种概念，或者一个承载数据的容器，是属于协议范畴的。

- 实体：作为请求或者响应的有效载荷数据，其内容有实体首部和实体主体组成。我理解的是其作为真实的实际上的被传输的数据，是属于实际应用范畴的。

​    报文的主体是用于传输请求或响应的实体主体的，通常报文主体就等同于实体主体。

### 1.4 HTTP状态码

#### 1.4.1 1×× 接收的请求正在处理

101 Switching Protocols，切换协议，可用于实现WebSocket通信

#### 1.4.2 2×× 请求成功处理

200 OK：请求已经被正常处理了

204 No Content：请求处理成功，但返回的响应报文不包含实体主体，也不允许包含实体主体。

206 Partial Content：范围请求，响应报文中包含了由请求首部Content-Range指定范围的实体内容

#### 1.4.3 3×× 重定向

301 Moved Permanently：永久性重定向

302 Found：临时性重定向

303 See Other：与302类似，但明确表示使用GET方法进行重定向

304 Not Modified：客户端发送了附带条件的请求（If-Modified-Since等），服务器资源并未改变，可直接使用客户端缓存

307 Temporary Redirect：类似302，虽然标准规定了302禁止在重定向时将方法从POST改成GET，但实际上并没有严格遵守，而返回307则会遵照标准，不会从POST改成GET。

#### 1.4.4 4×× 客户端错误

400 Bad Request：请求报文存在语法错误

401 Unauthorized：请求未携带认证信息

403 Forbidden：禁止访问

404 Not Found：未找到资源

405 Method Not Allowed

#### 1.4.5 5×× 服务器错误

500 Internal Server Error：服务器处理请求时出错

503 Service Unavailable：服务器超载或维护中

### 1.5 代理、网关、隧道

代理：转发而不会修改URI，进行缓存以及访问控制，缓存服务器是代理服务器的一种

网关：类似代理，但网关能使通信线路上的服务器提供非HTTP协议的服务。网关和服务器之间可以使用HTTP协议之外的协议，或者说利用网关可以由HTTP请求转化为其他协议通信。

隧道：通过隧道与远程服务器建立安全的通信线路。

### 1.6 HTTPS

#### 1.6.1 HTTPS = HTTP + 加密 + 认证 + 完整性验证

加密：防窃听；认证：防伪装；完整性校验：防篡改

​    所谓HTTPS协议，就是在HTTP协议与TCP协议之间增加了一层SSL协议，采用对称密码体系和公钥密码体系组合的混合加密方式，在交换密钥时使用公钥进行加密传输，之后的HTTP通信使用对称密钥进行加密。

#### 1.6.2 建立SSL连接：

1.  第一阶段SSL握手：

    客户端发送：Client Hello，开始SSL通信，报文中包含客户端支持的SSL的版本以及加密组件

    服务器发送：Server Hello，表示可进行SSL通信，报文中同样包含支持的SSL版本以及从接收到的客户端的加密组件中筛选出的加密组件

    服务器发送：Certificate，报文中包含公钥

    服务器发送：Server Hello Done，第一阶段SSL握手结束

2.  第二阶段SSL握手

    客户端发送：Client Key Exchange，报文中包含已经使用公钥加密的Pre-master secret随机密码串

    客户端发送：Change Cipher Spec，提示服务器此报文之后的通信会采用Pre-master secret密钥加密（其实是使用通过Pre-master secret生成的master secret来进行加密）

    客户端发送：Finished，报文中包含连接至今全部报文的整体校验值。第二阶段SSL握手是否成功，要看服务器是否可以正确解密该报文

3.  第三阶段SSL握手

    服务器发送：Change Cipher Spec

    服务器发送：Finished

4.  进行HTTP通信

    服务器和客户端的Finished报文交换完成之后，SSL连接就算建立完成，可以开始应用层协议的通信。应用发送数据时会附加一种MAC (Message Authentication Code) 报文摘要，用以保护报文完整性

5.  断开SSL连接

    客户端发送：Alert warning, close_notify

### 1.7 WebSocket

#### 1.7.1 HTTP的瓶颈

（1）一条连接上只能发送一个请求？

（2）请求只能从客户端开始，客户端不能接受除响应以外的指令

（3）请求/响应熟不未经压缩就发送

（4）每次都要发送相同的冗长的首部

（5）虽可以任意选择数据压缩格式，但并非强制压缩

#### 1.7.2 实现WebSocket通信

​    WebSocket即web浏览器与服务器之间进行全双工通信的标准。WebSocket是建立在HTTP基础上的协议，连接的发起者仍是客户端，但是之后可以确立WebSocket通信连接，一旦建立，不论服务器还是客户端都使用该协议进行通信，可向对方发送任意格式的数据。

​    WebSocket的主要特点就在：（1）推送功能，支持服务器向客户端推送数据；（2）减少通信量，只要建立起WebSocket连接，就可以一直保持连接状态，首部信息也很少。

WebSocket握手：

1.  请求，需要使用HTTP的Upgrade首部：

    Upgrade：websocket

    Connection: Upgrade

    Sec-WebSocket-Key: ×××

    Sec-WebSocket-Version: 13

    Sec-WebSocket-Key字段为握手过程必不可少的键值

2.  响应，对上述请求返回状态码101 Switching Protocols：

    HTTP/1.1 101 Switching Protocols

    Upgrade: websocket

    Connection: Upgrade

    Sec-WebSocket-Accept: ×××

    Sec-WebSocket-Accept是由握手请求中的Sec-WebSocket-Key生成的

    （3）WebSocket通信，成功握手建立WebSocket连接之后，通信时不再使用HTTP数据帧，而是使用WebSocket独立的数据帧

### 1.8 防止SQL注入攻击

1.  永远不要相信用户的输入，对输入参数进行严格校验，需要符合固定的格式和类型

2.  过滤特殊的符号，对一些特殊符号进行过滤或者转义

3.  不要拼接SQL语句，而是使用参数化的SQL语句，或者说预编译的SQL语句，使用?来代替变量，预编译的SQL语句其语义和结构不会改变

4.  应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装

5.  控制数据库的访问权限，只提供有限的访问权限

6.  不要将机密数据或者敏感数据直接存放数据库，而是进行加密或者hash计算之后存入数据库

# 二、MySQL数据库

## 1、数据库和数据库实例

数据库：物理文件的集合，依照某种数据模型组织起来的数据集合。

数据库实例：数据库实例是程序，是数据库管理软件，对数据库数据的任何操作都是通过数据库实例来完成的。数据库实例才是真正用于操作数据库文件的。

## 2、存储引擎简单对比

存储引擎是基于表的，而不是数据库。

<img src="/Users/admin/Library/Application Support/typora-user-images/image-20200806223717746.png" alt="image-20200806223717746" style="zoom:67%;" />

-   InnoDB：支持事务，面向在线事务处理（OLTP）应用，行锁设计，非锁定读，聚集索引，支持外键。InnoDB从1.2.x开始支持全文检索，并支持MyISAM的全部功能。

-   MyISAM：不支持事务，面向在线分析处理（OLAP），表锁设计，支持全文索引，只缓存索引而不缓存数据，支持压缩数据。

-   Memory：表中数据保存在内存中，表锁设计，默认使用哈希索引，使用Memory存储引擎表来存放查询的中间结果集。

## 3、InnoDB存储引擎

### 3.1 InnoDB体系架构

#### 3.1.1 InnoDB存储引擎组成：

<img src="/Users/admin/Library/Application Support/typora-user-images/image-20200806224118497.png" alt="image-20200806224118497" style="zoom:80%;" />

-   后台线程：刷新内存池中的数据，将已修改的数据刷新回磁盘文件

-   内存池：多个内存块组成的内存池

    -   维护多个进程/线程访问的内部数据结构

    -   缓存磁盘上的数据，缓存对磁盘文件的修改

    -   重做日志（redo log）缓存

### 3.1.2 后台线程

-   Master Thread：将缓冲池中的数据异步刷新到磁盘，保证数据的一致性

### 3.1.3 内存

（1）缓冲池

<img src="/Users/admin/Library/Application Support/typora-user-images/image-20200806224143861.png" alt="image-20200806224143861" style="zoom:80%;" />

-   读取页：将从磁盘中读取的页放在缓冲池中，称为将页FIX在缓冲池中。下一次读取相同的页，若该页在缓冲池中，称该页在缓冲池中被命中。

-   修改页：首先修改缓冲池中的页，然后以一定频率刷新到磁盘上（Master Thread）。

-   缓存的数据页：索引页，数据页，undo页，插入缓冲，自适应哈希索引，锁信息，数据字典信息

（2）LRU List、Free List和Flush List

1）LRU List

InnoDB存储引擎使用LRU算法对缓冲池中的页进行管理，但引入了midpoint：新读取到的页并不直接放到LRU List的首部，而是放到LRU List的midpoint位置，称为midpoint插入策略。默认midpoint在LRU List长度的5/8处，midpoint之前的5/8称为old列表，midpoint之后的3/8称为new列表。

为什么要引入midpoint？当进行索引或数据的扫描操作时，需要临时访问表中的许多页，如果将这些大量的临时非活跃的页插入LRU列表的首部，会导致很多热点数据页被从LRU列表中移除。

另外，InnoDB还引入了innodb_old_blocks_time参数，表示页读取到midpoint后需要等待多久才会被加入到LRU列表的new端。很容易理解，新读取的页首先放到midpoint位置，在规定的时间内如果仍然在LRU列表而没有被挤出，说明该页相对来说属于热点数据而被频繁读取。

2）Free List

LRU列表用来管理已经读取的页，当数据库刚启动时，LRU列表为空，此时页都存放在Free列表中。

3）脏页

当LRU列表中的页被修改之后，该页就称为脏页，即缓冲池中的页和磁盘中的页数据不一致。数据库会根据checkpoint机制将脏页刷新回磁盘，而Flush List中的页就是脏页列表。要注意，脏页既存在于LRU列表，也存在Flush List中。LRU列表用于管理缓冲池中页的可用性，而Flush列表用于管理刷新回磁盘的页，并不冲突。

### 3.2 Checkpoint技术

Write Ahead Log策略：当事务提交时，先写重做日志，再修改页，当发生宕机时，可通过重做日志来完成数据恢复。

Checkpoint所做的事总之就是将缓冲池中的脏页刷新回磁盘，但是每次刷新多少页、每次从哪里读取脏页以及何时触发Checkpoint都非常复杂。

Sharp Checkpoint：当数据库关闭时将所有脏页刷新回磁盘。

Fuzzy Checkpoint：只刷新一部分脏页。

## 4、索引与算法

### 4.1 InnoDB支持的索引

-   B+树索引

-   全文索引

-   哈希索引

    InnoDB支持的哈希索引是自适应的，InnoDB会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。InnoDB会自动根据访问的频率和模式来自动为热点页建立哈希索引，生成的哈希索引是通过缓冲池的B+树构造而来，不需要对整张表构建哈希索引。自适应哈希索引要求对某个页的连续访问模式是一样的，即查询的条件必须一模一样。不过，哈希索引只支持等值查询，范围查找是不能使用哈希索引的。

### 4.2 索引组织表

在InnoDB中，表都是根据主键顺序存放的，这种存储方式的表称为索引组织表。在InnoDB存储引擎表中，每张表都有个主键（\_rowid可以显示表的主键值）。如果创建表时没有显式定义主键，InnoDB会按如下方式选择或创建主键：

-   如果表中有非空的唯一索引（Unique Key Not Null）则以该列为主键。当表中有多个非空唯一索引时，将选择建表时第一个定义的非空唯一索引为主键（是非空唯一索引的定义顺序，而不是建表时列的顺序）
-   如果没有非空唯一索引，则自动创建一个6字节的指针。

### 4.3 B+树索引

#### 4.3.1 聚集索引

聚集索引就是按照索引组织表的主键构造一棵B+树，同时叶子节点存放的即是整张表的行记录数据，其叶子节点也称为数据页。所以，索引组织表中的数据也是索引的一部分。由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。

聚集索引能够在B+树的叶子节点上直接找到数据，而且由于定义了数据的逻辑结构，聚集索引的范围查找和排序查找速度非常快。

聚集索引的存储并不是物理上连续的，而是逻辑上连续的。逻辑上连续指的是，叶子节点按照主键顺序排列并通过双向链表连接，同时，叶子节点中的记录也是通过双向链表连接的。

#### 4.3.2 辅助索引（非聚集索引）

辅助索引的叶子节点并不包含行记录的数据，除了键值外，还有一个指向索引对应行数据的书签，也就是相应行数据的聚集索引键。

辅助索引并不影响聚集索引的组织，每张表可以有多个辅助索引。当通过辅助索引查找数据时，InnoDB会根据辅助索引找到叶子节点，由此获得主键索引的主键，在通过主键聚集索引找到行记录。

#### 4.3.3 B+树索引的分裂

要注意的是，B+树索引的分裂跟单纯的B+树分裂还是有区别的。B+树索引页的分裂并不总是从页的中间记录开始，否则可能会导致页空间的浪费。若插入的是随机的，则仍然取页的中间记录作为分裂点。但是插入往往是根据自增顺序插入的，如果依然按照中间记录作为分裂点，则分裂后左边的页可能永远不会有记录再插入，造成空间的浪费。

InnoDB可以决定向左还是向右分裂，同时决定分裂点位置。如果欲插入位置右边没有记录，则该待插入记录就是分裂点，即分离出的页只有待插入的记录。否则也会使得分裂出的节点拥有比较少的记录。

#### 4.3.4 Fast Index Creation

MySQL数据库对索引的添加和删除，首先创建一张临时表，临时表的定义即为原表创建或删除索引之后的结构，然后将原表数据导入临时表，删除原表，并将临时表重名为原表名。在这一过程中，MySQL数据库服务不可用。

对于辅助索引的添加，InnoDB支持Fast Index Creation（FIC），会对创建索引的表加上一个S锁，在创建索引的过程中只允许读操作，写操作依然不可用。但是创建过程中，不需要重建表，速度更快。

删除辅助索引，将辅助索引的空间标记为可用（就是清除辅助索引空间的意思？），同时删除MySQL数据库内部视图上对该表的索引定义即可。

FIC方式只限定于辅助索引，主键索引的创建和删除同样需要重建表。

#### 4.3.4 B+树索引的适用场景

字段的取值范围很小，称为低选择性，相反，取值范围很广，属于高选择性。

当访问表中很少一部分，字段属于高选择性时，就非常适合添加B+树索引。

通过SHOW INDEX FROM tb_name可以看到表中所有索引列的信息，每个索引会有一个Cardinality属性（这个属性是针对索引列的），表示索引中不重复记录数量的预估值。实际应用中，Cardinality/n_rows_in_table应尽可能接近1，那么表示该索引列具有高选择性，索引的创建就非常有价值。

Cardinality表示索引列的选择性。InnoDB对Cardinality的更新时机发生在两个操作上：INSERT和UPDATE，但并非每次操作就更新，而是：

· 表中1/16的数据发生过变化

· 某一行数据频繁地更新超过某个值

时才会更新Cardinality。而对Cardinality的统计是采用随机采样的方式：随机取B+树的8个叶子节点，统计每页不同记录的个数，再预估整个表中的不同记录数。每次对Cardinality值的统计，可能会有不同的结果，也可能都一样（表足够小，叶子节点没超过8个）。

#### 4.3.5 覆盖索引

覆盖索引/索引覆盖，即从**辅助索引**中就可以得到查询的记录，而不需要查询聚集索引中的记录。辅助索引不包含整行记录的信息，远小于聚集索引，可以减少IO操作。

InnoDB中的辅助索引包含了主键，因此在仅针对主键和辅助索引列的查询时，仅使用一次辅助索引即可完成查询。

另外覆盖索引也可以提高统计查询的速度。由于辅助索引远小于聚集索引，通过辅助索引可以减少IO操作，进而快速的进行统计，而不是通过聚集索引。而且，通常情况下，对于联合索引，针对**非**最左前缀的查询，是不能通过联合索引来查询的。但是如果是统计操作，并且是覆盖索引，优化器依然会选择联合索引。（当最左前缀相同时，中间索引列是排序的）

- 扫描聚集索引：即扫描全表

- 查找聚集索引：根据主键进行查找

当查询的数据包含整行的部分或全部信息时，不能仅通过辅助索引进行索引覆盖时，优化器也可能还是会选择辅助索引，这通常是查询的数据较少的情况下。这时意味着通过辅助索引查找到数据后还需要进行书签查找，即通过主键查找聚集索引。

上面这一段理解一下。如果某个查询条件包含辅助索引列，且需要查询整行信息，此时就不是覆盖索引。但是优化器依然选择了辅助索引，这前提是通过辅助索引查找到的数据量很少。如果数据量很多（\>全表的20%），那么优化器会直接扫描聚集索引，也就是进行全表扫描（因为查询条件并不包含主键，如果包含主键的话就直接根据主键查找聚集索引而不是全表扫描，就没这么多事了）。

### 4.4 全文检索

#### 4.4.1 倒排索引（inverted index）

全文检索通常使用倒排索引来实现。倒排索引也是一种索引结构，存放在辅助表（Auxiliary Table）中，存储了单词与单词自身在一个或多个文档中所在位置之间的映射，有两种表现形式：

- inverted file index：{单词，单词所在文档ID}

- full inverted file index：{单词，{单词所在文档ID，在文档中的位置}}

#### 4.4.2 InnoDB全文检索（Full Test Search, FTS）

InnoDB从1.2.x开始支持全文检索，采用full inverted index，即{word, {DocumentId, Position}}，将{DocumentId, Position}视为一个ilist，并且在word字段上设有索引。InnoDB中，存放倒排索引的辅助表共有6张，这种表是持久的表，存放在磁盘上。

InnoDB中还有FTS Index Cache（全文检索索引缓存），是一个红黑树结构，根据（word，ilist）进行排序。当插入新的数据时，InnoDB并不会马上更新辅助表，而是先放在FTS Index Cache中，然后批量更新全文索引。当进行全文检索时，会先将FTS Index Cache中的全文索引合并（同步/刷新）到辅助表，然后再进行查询。

这里所说的"单词所在文档"，或者DocumentId中的Document就是进行全文检索的字段值，即一行数据中的TEXT格式的数据。对于支持全文检索的表都有一个关键的FTS_DOC_ID列（类型必须为BIGINT UNSIGNED NOT NULL），用来与word进行映射，InnoDB会自动为FTS_DOC_ID添加唯一索引。

当文档中发生删除操作时，并不会删除辅助表中的记录，而只是删除FTS Index Cache中的记录，并将其保存到DELETED Auxiliary table中（只记录FTS Document ID）。

为表创建全文检索索引时，先导入数据，再进行倒排索引（全文索引）的创建，是比较推荐的一种方式。

InnoDB的全文检索有以下限制：

- 每张表只能有一个全文检索的索引；

- 多列组合的全文检索索引列必须使用相同的字符集与排序规则

- 不支持没有单词界定符的语言，比如中文日语韩语

## 5、锁

### 5.1 lock和latch

latch为轻量级的锁，在InnoDB中分为mutex互斥量和rwlock读写锁。其目的是用来保证并发线程操作临界资源（critical area）的正确性，并且通常没有死锁检测。

lock的对象是事务，用来锁定数据库中的对象，如表、页、行。lock的对象仅在事务commit或rollback之后进行释放。并且lock有死锁机制。

<img src="/Users/admin/Library/Application Support/typora-user-images/image-20200806225124620.png" alt="image-20200806225124620" style="zoom:80%;" />

<img src="/Users/admin/Library/Application Support/typora-user-images/image-20200806225133869.png" alt="image-20200806225133869" style="zoom:80%;" />

### 5.2 InnoDB存储引擎中的锁

#### 5.2.1 锁的类型

-   共享锁（S Lock），允许事务读取一行数据

- 排他锁（X Lock），允许事务删除/更新一行数据

  S锁之间可以兼容，而X锁与任何锁都不兼容。S和X锁都是行锁，兼容指的是对同一行记录锁的兼容性。

  InnoDB支持多粒度的锁，同时支持表级锁和行级锁。那么粗粒度的锁和细粒度的锁之间就会存在冲突。因此InnoDB增加了意向锁，它实际上是一种表锁。InnoDB支持两种意向锁：

-   意向共享锁（IS Lock），表示事务想要或已经获得表的某几行的共享锁

- 意向排它锁（IX Lock），表示事务想要或已经获得表的某一行排他锁

当对最细粒度的对象（行）加锁时，首先需要对粗粒度的对象（表）上锁，即当需要对行加上X锁时，需要先对数据库、表、页加上意向锁IX，然后再对行加上X锁。

理解一下意向锁，它的出现是为了解决表锁和行锁的冲突问题。因为InnoDB同时支持行级锁和表级锁，假设事务A获得行S/X锁，事务B获得表锁（ALTER TABLE/DROP TABLE/LOCK TABLE)，那么事务B理应可以修改所有行，这与事务A的行S/X锁冲突。所以，在加表锁时，应当判断此时表是否有其他表锁以及行级锁，那么需要遍历全部行来判断是否有行级锁。反之，在加行锁时不仅要判断当前行是否有其他行级锁，也需要判断锁定行所在表是否有表级锁。基于此，引入了意向锁。当要加上行级S/X锁时，数据库会**自动**对表加上相应的意向锁IS/IX，表示这张表即将或已经加上了行级锁。而意向锁也是一种表级锁，它会与其他的表锁冲突，因此可以阻塞其他的表锁请求，或者阻塞自己的意向锁请求并因此阻塞相应行级锁的请求，避免粗粒度锁和细粒度锁的冲突。

但是，意向锁之间并不会冲突。因为意向锁是在加上行级锁之前所加的锁，而行级锁之间的兼容问题的前提是，请求锁定的是同一行。所以，假设事务A请求行S锁，那么会首先加上意向IS锁，事务B同时请求X锁，会首先加上意向IX锁，意向锁之间是兼容的，因此IS和IX可以共存。如果事务A锁定的行和事务B锁定的行并不是同一行，那么它们之间就不存在兼容冲突问题。如果是同一行，那么就按照行级锁的兼容规则，阻塞其中一方。

<img src="/Users/admin/Library/Application Support/typora-user-images/image-20200806225315218.png" alt="image-20200806225315218" style="zoom:80%;" />

这张图如何理解S/X锁和IS/IX之间的兼容？我理解的是，这里的S/X锁和意向锁IS/IX之间的兼容或不兼容，应该指的是表级S/X锁和意向锁IS/IX之间的兼容问题。因为意向锁本身就是在加上行级S/X锁之前加的表级锁，因此行级S/X锁和意向锁IS/IX肯定是不冲突的。这里与意向锁IS/IX的兼容问题应该指的是表级S/X锁。（但是前面不是说S/X锁是行级锁吗？怎么又有表级S/X锁？）

#### 5.2.2 一致性非锁定读

一致性非锁定读是通过版本控制实现的：当读取的行正在执行DELETE/UPDATE，即被加上了行X锁时，读取操作无需等待行X锁的释放（也就是不加行S锁的读），而是读取行的一个快照数据。

快照数据指的是行之前的版本数据，也就是有关该行的事务提交一次，就会产生一个该行的历史版本。快照是通过undo段来实现的，而undo是用来在事务中回滚的，因此快照数据本身并没有额外的开销。并且，读取快照数据不需要上锁，因为没有事务是需要对历史数据进行修改操作的。

一致性非锁定读是InnoDB的默认读取方式，即读取不会占用和等待表上的锁。但是在不同事务隔离级别下，读取的方式不同，而且并不是在每个事务隔离级别下都是采用非锁定的一致性读（InnoDB默认隔离级别是可重复度）。即使是使用非锁定的一致性读，读取快照的方式也都不一样。

快照数据就是当前行数据之前的历史版本，每行记录可以有多个版本。这种通过行多版本技术来控制并发的手段，称之为多版本并发控制。

READ COMMITTED和REPEATABLE READ下，InnoDB都使用非锁定的一致性读。但是READ COMMITTED总是读取读取被锁定行的最新一份快照数据。而REPEATABLE READ总是读取事务开始时的行数据版本。

#### 5.2.3 一致性锁定读

